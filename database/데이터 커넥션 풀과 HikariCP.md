# 데이터 커넥션 풀과 HikariCP

## 1. 데이터 커넥션
데이터 커넥션은 애플리케이션이 데이터베이스와 통신하는 연결을 의미합니다. 데이터베이스 커넥션의 생애 주기는 다음과 같습니다.

1. **데이터베이스 드라이버**를 사용하여 연결 설정
2. 데이터를 읽고 쓰기 위해 **TCP 소켓** 열기
3. **TCP 소켓**을 통해 데이터 통신
4. **데이터베이스 연결 닫기**
5. **TCP 소켓 닫기**

이 과정은 매번 새로운 요청이 들어올 때마다 반복되며, 시간과 리소스 측면에서 많은 비용이 듭니다.

## 2. 데이터베이스 커넥션 풀 (DBCP)
데이터베이스 커넥션 풀(DBCP)은 애플리케이션이 데이터베이스와 연결하는 작업의 비용을 줄이기 위해 미리 일정 수의 커넥션을 생성해 두는 기법입니다.

### 동작 방식
- **미리 생성된 커넥션**이 풀에 저장됩니다.
- 애플리케이션에서 데이터베이스 연결이 필요할 때, 풀에서 **사용 가능한 커넥션을 대여**합니다.
- 사용이 끝난 후 커넥션은 풀에 **반납**됩니다.

이를 통해 매번 새로운 연결을 설정하는 비용을 줄일 수 있으며, 데이터베이스와의 연결 효율성을 크게 향상시킬 수 있습니다.

## 3. HikariCP
### 개요
HikariCP는 성능이 우수한 **JDBC 데이터베이스 커넥션 풀링 프레임워크**로, **스프링 부트**에 기본적으로 내장되어 있습니다. 스프링 부트에서는 HikariCP가 사용 가능하면 이를 사용하고, 그렇지 않으면 다른 커넥션 풀 옵션을 순차적으로 선택합니다. 그 순서는 다음과 같습니다:

1. HikariCP
2. Tomcat DBCP
3. Apache Commons DBCP
4. Oracle UCP

## 4. Deadlock(교착상태)
HikariCP를 사용할 때 주의해야 할 문제 중 하나는 **교착상태(Deadlock)**입니다. Deadlock은 여러 쓰레드가 서로의 커넥션 반납을 기다리며 영원히 대기하는 상황입니다.

### Deadlock 시나리오
1. **Thread-1**은 작업을 수행하기 위해 **2개의 DB 커넥션**이 필요합니다.
2. 하지만 **DBCP의 사이즈는 1개**입니다. (total = 1, active = 0, idle = 1, waiting = 0)
3. Thread-1은 DBCP로부터 **1개의 커넥션**을 받아옵니다.
4. 그러나 1개의 커넥션으로는 작업을 완료할 수 없어 다른 커넥션이 반납되기를 기다립니다.
5. 하지만 DBCP의 상태는 `total = 1, active = 1, idle = 0, waiting = 0`입니다. 반납될 커넥션이 없어 **Thread-1**은 **자기 자신이 커넥션을 반납하기를 기다리는 상황**에 빠집니다. 이것이 바로 Deadlock입니다.

## 5. Deadlock 해결 방안
HikariCP 팀은 **DBCP 최소 사이즈 공식**을 제안했습니다. 이 공식은 Deadlock을 피하기 위한 최소 커넥션 수를 계산하는 방법입니다:

Tn * (Cm - 1) + 1
여기서:
- **Tn**: WAS의 전체 쓰레드 개수
- **Cm**: 쓰레드가 동시에 필요로 하는 DB 커넥션 개수

### 예시
만약 **쓰레드 최대 개수**가 10개, **동시에 필요한 커넥션 수**가 3개라면:
이 공식에 따르면, 최소한 21개의 커넥션이 필요합니다. 이를 통해 Deadlock을 방지할 수 있습니다.

### α 값 조정
위 공식은 **Deadlock을 피하기 위한 최소값**을 제공하므로, 실제 운영 환경에서는 성능 테스트를 통해 최적의 **α 값을 추가**하여 적절한 커넥션 풀 크기를 찾아야 합니다. 무작정 커넥션 풀을 크게 설정할 수는 없기 때문에, 메모리 사용량과 성능 간의 균형을 맞춰야 합니다.

